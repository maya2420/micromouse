#include <AccelStepper.h>
//const int stepsPerRev= 200;
AccelStepper mystepperLeft(1, 5, 4);
AccelStepper mystepperRight(1, 8, 7);

bool stuck = true;  //We will use this to signal when all IR sensors detect a dead-end

void goStraight(void);
void go_short(void);
int SR = 0, FR = 0, FL = 0, SL = 0;

//void turnRight(){
// mystepperRight.setCurrentPosition(0);
// mystepperRight.moveTo(632);
// mystepperRight.runToPosition();

void turnLeft(void);
void turnLeft(void);
void oneeighty(void);

//Adjustments can made via small tail-fin manuever,
//by individualy changing single motor accell or speed

void setup() {
  // put your setup code here, to run once:
  mystepperLeft.setMaxSpeed(1000);
  mystepperLeft.setAcceleration(5000);  //getting up to setMax speed
  mystepperLeft.setCurrentPosition(0);


  mystepperRight.setMaxSpeed(1000);
  mystepperRight.setAcceleration(5000);
  mystepperRight.setCurrentPosition(0);

  pinMode(9, OUTPUT);     //this pin is M1, used to configure modes for fractional steps
  pinMode(10, OUTPUT);    //this pin is M2, used to configure modes for fractional steps
  digitalWrite(9, HIGH);  //We use this to make half-steps
  digitalWrite(10, LOW);  //Must be turned off to make half-steps

  pinMode(A0, INPUT);
  pinMode(A1, INPUT);
  pinMode(A2, INPUT);
  pinMode(A3, INPUT);

  // for position and orientation functions
  int orientation = 1; 
  int pos[3] = {0,0,0};
  const int UP = 1;
  const int RIGHT = 2;
  const int DOWN = 3;
  const int LEFT = 4;
}

void loop() {
  // put your main code here, to run repeatedly:
  SR = analogRead(A0);
  FR = analogRead(A1);
  FL = analogRead(A2);
  SL = analogRead(A3);

  if (FR > 950 || FL > 950) {
    goStraight();
  } else if (SR > 950) {
    turnRight();
    updateOrientationCW(orientation);
  } else if (SL > 950) {
    turnLeft();
    updateOrientationCCW(orientation)
  } else if (FR < 950 && FL < 950 && SR < 950 && SL < 950) {
    oneeighty();
    updateOrientationCW(orientation);
    updateOrientationCW(orientation);
  }

    updatePosition(pos[], orientation, currentPosition);

    // for testing:
    Serial.println("X position: ");
    Serial.println(pos[0]);
    Serial.println("Y position: ");
    Serial.println(pos[1]);
}

void turnLeft(void) {

  mystepperRight.move(490);

  while (mystepperLeft.distanceToGo() > 0 || mystepperRight.distanceToGo() > 0) {
    mystepperRight.run();
  }
}


void turnRight(void) {


  mystepperLeft.move(490);

  while (mystepperLeft.distanceToGo() > 0 || mystepperRight.distanceToGo() > 0) {
    mystepperLeft.run();
  }
}



void goStraight(void) {

  mystepperLeft.move(12224);
  mystepperRight.move(12224);

  while (mystepperLeft.distanceToGo() > 0 || mystepperRight.distanceToGo() > 0) {
    // Run the stepper motors towards their set positions
    mystepperLeft.run();
    mystepperRight.run();
    SR = analogRead(A0);
  FR = analogRead(A1);
  FL = analogRead(A2);
  SL = analogRead(A3);


    if (FR < 950 || FL < 950) {
      mystepperLeft.move(250);
      mystepperRight.move(250);
      while (mystepperLeft.distanceToGo() > 0 || mystepperRight.distanceToGo() > 0) {
        // Run the stepper motors towards their set positions
        mystepperLeft.run();
        mystepperRight.run();
      }
      break;
    }
  }
}
void oneeighty(void) {
  mystepperLeft.setAcceleration(4000);
  mystepperRight.setAcceleration(4000);

  mystepperRight.setCurrentPosition(0);
  mystepperLeft.setCurrentPosition(0);

  mystepperLeft.moveTo(480);
  mystepperRight.moveTo(-480);


  while ((mystepperLeft.distanceToGo() > 0) || mystepperRight.distanceToGo() > 0) {
    mystepperLeft.run();
    mystepperRight.run();
  }
  mystepperLeft.setAcceleration(4000);
  mystepperRight.setAcceleration(4000);
}


void updateOrientationCW(int & orientation) { // turn clockwise
  orientation++;

  if (orientation == 5) {
    orientation = UP;
  }
  return;
}
void updateOrientationCCW(int & orientation) { // turn counterclockwise
  orientation--;

  if (orientation == 0) {
    orientation = LEFT;
  }
  return;
}

void updatePosition(int pos[], int orientation, int currentPosition) {

  int unitPosition = currentPosition/764 //1 unit is 764 steps
  if (orientation == UP) {
    pos[1] = pos[1] + unitPosition;
  }
  if (orientation == RIGHT) {
    pos[0] = pos[0] + unitPosition;   
  }
  if (orientation == DOWN) {
    pos[1] = pos[1] - unitPosition;
  }
  if (orientation == LEFT) {
    pos[0] = pos[0] - unitPosition;
  }
  currentPosition = 0;

  return;
}
