#include <AccelStepper.h>
//const int stepsPerRev= 400;
AccelStepper mystepperLeft(1, 5, 4);
AccelStepper mystepperRight(1, 8, 7);


int SR = 0, FR = 0, FL = 0, SL = 0;  //storing the value of the infrared sensors

int cruiseR = 1000;  // modified cruise speed of right wheel to keep you centered
int cruiseL = 1000;  // modified cruise speed of left wheel to keep you centered
int cruise = 1000;   // actual cruising speed when searching

unsigned long lasttime = 0;  // for doing delays kinda. just go look.
int straightCount = 0;

void goStraight(int straightCount);  // self explanatory
void turnLeft(void);                 // self explanatory
void turnRight(void);                // self explanatory
void oneeightyRight(void);           // self explanatory but it turns in the direction of the wall it's furthest from
void oneeightyLeft(void);            // self explanatory but it turns in the direction of the wall it's furthest from
void unfuck(void);                   //this function keeps you centetred between maze walls when navigating
void stop(int stopIn);               //this function makes you stop
void find();                         //finds next block in the pathway
void whereTo();                      //finds what direction that block is in
void turnToDirections();             //puts information into directions of brudder
void go();
void goToStart();
void wallcheck(void);

int maze[5][5] = { 0 };
int dir = 1, xpos = 0, ypos = 0, dis = 6;  //direction the mouse is initially facing incrementing by one every 90 degrees clockwise and repeating after 4.
int checkspot = 764;                         //initially set to zero to check starting position
bool deadend = 0;
bool branch = 0, searching = 1;

int cX = 0;
int cY = 0;
int oX = 0;
int oY = 0;
int virdir = 1;        //direction going to go in, not current direction
int vals[50] = { 0 };  //{1,1,1,2,2,2,2,3,4,3,4,4,3,2,2,2,1};
int valsSize = 0;
bool turn = 0;           // true = right; false = left;
int c = 0;               // current
int f = 1;               //future
int x = 0;               //incrementing
int CountW = 0;          //counts in the where function
bool turnList[100];      //turns array
int distList[100];       //distance array
int directionsSize = 0;  // size of directions list
int moveCount = 6;      //how many moves made
int goalX = 0;
int goalY = 1;
int block = 1;  //distance counter
int countPos = 2;
bool pathFound = false;

int matrix[5][5] = { { 1, 2, 3, 0, 0 },
                     { 6, 5, 4, 0, 0 },
                     { 0, 0, 0, 0, 0 },
                     { 0, 0, 0, 0, 0 },
                     { 0, 0, 0, 0, 0 } };


//--------------------------------------------------
void setup() {
  mystepperLeft.setMaxSpeed(cruise);
  mystepperLeft.setAcceleration(4000);
  mystepperLeft.setCurrentPosition(0);

  Serial.begin(9600);

  mystepperRight.setMaxSpeed(cruise);
  mystepperRight.setAcceleration(4000);
  mystepperRight.setCurrentPosition(0);

  pinMode(9, OUTPUT);   //this pin is M1, used to configure modes for fractional steps
  pinMode(10, OUTPUT);  //this pin is M2, used to configure modes for fractional steps

  digitalWrite(9, HIGH);  //if 9 is low and 10 is low you do full steps. 9 high 10 low is half steps. 10 high 9 low quarter steps. 9 high 10 high eight steps
  digitalWrite(10, LOW);

  pinMode(A0, INPUT);
  pinMode(A1, INPUT);
  pinMode(A2, INPUT);
  pinMode(A3, INPUT);

  maze[0][0] = 1;

}

void loop() {
 for (int d = 0; d < dis-1 ; d++) { 
    find();
    whereTo();
  } 

  for (int i = 0; i < dis-1 ; i++){
    turnToDirections();
  }

  goToStart();
  //go();
  

  if(pathFound){
    //go();
    while(true){

    }
  }
}

void oneeightyRight(void) {

  //mystepperRight.setAcceleration(4000);
  //mystepperLeft.setAcceleration(4000);

  dir = dir + 2;
  if (dir == 5) {
    dir = 1;
  }
  if (dir == 6) {
    dir = 2;
  }

  mystepperRight.setCurrentPosition(0);
  mystepperLeft.setCurrentPosition(0);

  mystepperLeft.moveTo(540);
  mystepperRight.moveTo(-540);


  while ((mystepperLeft.distanceToGo() > 0) || mystepperRight.distanceToGo() > 0) {
    mystepperLeft.run();
    mystepperRight.run();
  }
}

void oneeightyLeft(void){

  //mystepperRight.setAcceleration(4000);
  //mystepperLeft.setAcceleration(4000);

  dir = dir - 2;
  if (dir == 0) {
    dir = 4;
  }
  if (dir == -1) {
    dir = 3;
  }

  mystepperRight.setCurrentPosition(0);
  mystepperLeft.setCurrentPosition(0);

  mystepperLeft.moveTo(-540);
  mystepperRight.moveTo(540);


  while ((mystepperLeft.distanceToGo() > 0) || mystepperRight.distanceToGo() > 0) {
    mystepperLeft.run();
    mystepperRight.run();
  }

}

void stop(int stopIn) {
  mystepperLeft.move(stopIn);
  mystepperRight.move(stopIn);
  while (mystepperLeft.distanceToGo() > 0 || mystepperRight.distanceToGo() > 0) {
    // Run the stepper motors towards their set positions
    mystepperLeft.run();
    mystepperRight.run();
  }
  mystepperRight.setCurrentPosition(0);
  mystepperLeft.setCurrentPosition(0);
  checkspot = 0;
  posup();
  cruiseL = cruise;
  cruiseR = cruise;
  mystepperLeft.setMaxSpeed(cruise);
  mystepperRight.setMaxSpeed(cruise);
}

void goStraight(int straightCount) {

  mystepperRight.setCurrentPosition(0);
  mystepperLeft.setCurrentPosition(0);

  mystepperLeft.move(straightCount);
  mystepperRight.move(straightCount);

  while (mystepperLeft.distanceToGo() > 0 || mystepperRight.distanceToGo() > 0) {
    // Run the stepper motors towards their set positions
    mystepperLeft.run();
    mystepperRight.run();
    SR = analogRead(A0);
    FR = analogRead(A1);
    FL = analogRead(A2);
    SL = analogRead(A3);

    unfuck();
    posup();

  if ((FR < 950 || FL < 950) && searching == 1) {
      stop(300);
      break;
    }
    // if in the searching phase, look ahead
    if (searching == 1) {
      //lookAhead(764);
    }
  }
}

void turnRight(void) {

  mystepperRight.setCurrentPosition(0);
  mystepperLeft.setCurrentPosition(0);

  dir = dir + 1;
  if (dir > 4) {
    dir = 1;
  }

  checkspot = 382;

  mystepperLeft.move(540);

  while (mystepperLeft.distanceToGo() > 0 || mystepperRight.distanceToGo() > 0) {
    mystepperLeft.run();
  }
}

void turnLeft(void) {
  mystepperRight.setCurrentPosition(0);
  mystepperLeft.setCurrentPosition(0);

  dir = dir - 1;
  if (dir < 1) {
    dir = 4;
  }

  checkspot = 382;

  mystepperRight.move(540);

  while (mystepperLeft.distanceToGo() > 0 || mystepperRight.distanceToGo() > 0) {
    mystepperRight.run();
  }
}

void unfuck(void) {
  if (millis() - lasttime > 1) {
    lasttime = millis();
    if (SL < 800) {
      cruiseL = cruise - SL + 800;
      mystepperLeft.setMaxSpeed(cruiseL);
    }
    if (SR < 800) {
      cruiseR = cruise - SR + 800;
      mystepperRight.setMaxSpeed(cruiseR);
    }
  }
}

void posup(void) {
  if (mystepperLeft.currentPosition() >= checkspot) {
    checkspot = checkspot + 764;
    if (dir == 2) {
      ypos = ypos + 1;
    }
    if (dir == 1) {
      xpos = xpos + 1;
    }
    if (dir == 4) {
      ypos = ypos - 1;
    }
    if (dir == 3) {
      xpos = xpos - 1;
    }
    wallcheck();
    mazeup();
  }
}

void mazeup(void) {
  if (maze[xpos][ypos] != 0 && maze[xpos][ypos] < 100) {
    dis = maze[xpos][ypos];
    maze[xpos][ypos] = maze[xpos][ypos] + 200;
  }
  if (maze[xpos][ypos] == 0 && branch == 0 && deadend == 0) {
    dis = dis + 1;
    maze[xpos][ypos] = dis;
  }
  if (deadend == 1) {
    dis = dis + 1;
    maze[xpos][ypos] = dis + 200;
  }
  if (maze[xpos][ypos] == 0 && branch == 1) {
    dis = dis + 1;
    maze[xpos][ypos] = dis + 100;
  }

  if (maze[xpos][ypos] > 100 && maze[xpos][ypos] < 200 && branch == 0) {
    dis = maze[xpos][ypos] - 100;
    maze[xpos][ypos] = maze[xpos][ypos] - 100;
  }
  if (maze[xpos][ypos] > 100 && maze[xpos][ypos] < 200 && branch == 1) {
    dis = maze[xpos][ypos] - 100;
  }
  deadend = 0;
  branch = 0;
}
void wallcheck(void) {
  SR = analogRead(A0);
    FR = analogRead(A1);
    FL = analogRead(A2);
    SL = analogRead(A3);
  if (FR < 950 && FL < 950 && SR < 950 && SL < 950) {
    deadend = 1;
  }
  if (FR > 950 && SR > 950) {
    branch = 1;
    if (dir == 1 && (maze[xpos][ypos + 1] != 0 || maze[xpos + 1][ypos] != 0)) {
      branch = 0;
    }
    if (dir == 2 && (maze[xpos][ypos + 1] != 0 || maze[xpos - 1][ypos] != 0)) {
      branch = 0;
    }
    if (dir == 3 && (maze[xpos][ypos - 1] != 0 || maze[xpos - 1][ypos] != 0)) {
      branch = 0;
    }
    if (dir == 4 && (maze[xpos][ypos - 1] != 0 || maze[xpos + 1][ypos] != 0)) {
      branch = 0;
    }
  }
  if (FL > 950 && SL > 950) {
    branch = 1;
    if (dir == 1 && (maze[xpos][ypos - 1] != 0 || maze[xpos + 1][ypos] != 0)) {
      branch = 0;
    }
    if (dir == 2 && (maze[xpos][ypos + 1] != 0 || maze[xpos + 1][ypos] != 0)) {
      branch = 0;
    }
    if (dir == 3 && (maze[xpos][ypos + 1] != 0 || maze[xpos - 1][ypos] != 0)) {
      branch = 0;
    }
    if (dir == 4 && (maze[xpos][ypos - 1] != 0 || maze[xpos - 1][ypos] != 0)) {
      branch = 0;
    }
  }
  if (SR > 950 && SL > 950) {
    branch = 1;
    if (dir == 2 && (maze[xpos + 1][ypos] != 0 || maze[xpos - 1][ypos] != 0)) {
      branch = 0;
    }
    if (dir == 1 && (maze[xpos][ypos + 1] != 0 || maze[xpos][ypos - 1] != 0)) {
      branch = 0;
    }
    if (dir == 4 && (maze[xpos + 1][ypos] != 0 || maze[xpos - 1][ypos] != 0)) {
      branch = 0;
    }
    if (dir == 3 && (maze[xpos][ypos + 1] != 0 || maze[xpos][ypos - 1] != 0)) {
      branch = 0;
    }
  }
}


void find() {
  for (int i = 0; i < 5; i++) {
    for (int j = 0; j < 5; j++) {
      if (matrix[i][j] == countPos) {
        countPos++;
        cX = i;
        cY = j;
        return;
      }
    }
  }
}

void whereTo() {

  if (oX > cX) {
    virdir = 3;
  }

  if (oX < cX) {
    virdir = 1;
  }

  if (oY > cY) {
    virdir = 2;
  }

  if (oY < cY) {
    virdir = 4;
  }

  oX = cX;
  oY = cY;
  vals[CountW] = virdir;
  valsSize++;
  CountW++;
}

void turnToDirections() {

  if (vals[c] == vals[f]) {
    block++;

  } else if (vals[c] == 1 && vals[f] == 4) {
    turn = false;
    turnList[x] = turn;
    distList[x] = (block * 764) - 340;
    block = 1;
    directionsSize++;


  } else if (vals[c] == 4 && vals[f] == 1) {
    turn = true;
    turnList[x] = turn;
    distList[x] = (block * 764) - 340;
    block = 1;
    directionsSize++;
    

  } else if (vals[c] != 4 && vals[c] < vals[f]) {
    turn = true;
    turnList[x] = turn;
    distList[x] = (block * 764) - 340;
    block = 1;
    directionsSize++;

  } else {
    turn = false;
    turnList[x] = turn;
    distList[x] = (block * 764) - 340;
    block = 1;
    directionsSize++;
  }

  c++;
  f++;
  x++;
}

void go(){
  cruiseR = 2000;
  cruiseL = 2000;
  cruise = 2000;
  oneeightyRight();
  for (int i = 0; i < dis; i++) {
    if (distList[i] != 0) {
      goStraight(distList[i]);
    }

    if(turnList[i] != 0){
      if (turnList[i] == true) {
        turnRight();
      } 
      else if (turnList[i] == false) {
        turnLeft();
      }
    }
  }

  while(true){

  }
}

void goToStart() {
  
  
  //oneeightyRight();
  Serial.println("----------");
  for (int i = dis ; i >= 0; i--) {
    if (distList[i] != 0) {
      
      Serial.print("i: ");
      Serial.print(i);
      Serial.println(" - ");
      goStraight(distList[i]);
      Serial.println(distList[i]);
    }

    if(turnList[i] != 0){
      Serial.println(turnList[i]);
      if (turnList[i] == false) {
        turnRight();
      } 
      else if (turnList[i] == true) {
        turnLeft();
      }
    }

  }
  pathFound = true;
}



